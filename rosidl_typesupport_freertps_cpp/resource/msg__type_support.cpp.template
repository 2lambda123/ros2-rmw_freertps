// generated from rosidl_typesupport_freertps_cpp/resource/msg__type_support.cpp.template

@#######################################################################
@# EmPy template for generating <msg>__type_support.cpp files
@#
@# Context:
@#  - spec (rosidl_parser.MessageSpecification)
@#    Parsed specification of the .msg file
@#  - subfolder (string)
@#    The subfolder / subnamespace of the message
@#    Either 'msg' or 'srv'
@#  - get_header_filename_from_msg_name (function)
@#######################################################################
@
#include <limits>
#include <stdexcept>
#include <cstring>

extern "C"
{
#include "freertps/pub.h"
#include "freertps/freertps.h"
}

#include <rosidl_generator_c/message_type_support.h>
// this is defined in the rosidl_typesupport_freertps_cpp package and
// is in the include/rosidl_typesupport_freertps_cpp/impl folder
#include <rosidl_generator_cpp/message_type_support.hpp>
#include <rosidl_typesupport_freertps_cpp/visibility_control.h>

@{header_file_name = get_header_filename_from_msg_name(spec.base_type.type)}@
#include "@(spec.base_type.pkg_name)/@(subfolder)/@(header_file_name)__struct.hpp"
#include "@(spec.base_type.pkg_name)/@(subfolder)/dds_freertps/@(header_file_name)__type_support.hpp"
#include "rosidl_typesupport_freertps_cpp/identifier.hpp"
#include <rosidl_typesupport_freertps_cpp/message_type_support.h>

// forward declaration of conversion functions for message dependencies
@[for field in spec.fields]@
    @[if not field.type.is_primitive_type()]@
@{
dependency_subfolder = "msg"
if field.type.type.endswith("Request") or field.type.type.endswith("Response"):
    dependency_subfolder = "srv"
}@
namespace @(field.type.pkg_name)
{
namespace @(dependency_subfolder)
{
namespace typesupport_freertps_cpp
{

uint32_t serialize_ros_msg(
  const @(field.type.pkg_name)::@(dependency_subfolder)::@(field.type.type) & ros_message,
  uint8_t * _buf,
  uint32_t _buf_size);

bool deserialize_ros_msg(
  uint8_t ** message_pointer,
  @(field.type.pkg_name)::@(dependency_subfolder)::@(field.type.type) & ros_message,
  uint32_t * length);

}  // namespace typesupport_freertps_cpp
}  // namespace msg
}  // namespace @(field.type.pkg_name)

    @[end if]@
@[end for]@

namespace @(spec.base_type.pkg_name)
{

namespace @(subfolder)
{

namespace typesupport_freertps_cpp
{


typedef @(spec.base_type.pkg_name)::@(subfolder)::@(spec.base_type.type) __ros_msg_type;

ROSIDL_TYPESUPPORT_FREERTPS_CPP_EXPORT_@(spec.base_type.pkg_name)
uint32_t serialize_ros_msg(
  const __ros_msg_type & ros_message,
  uint8_t * _buf,
  uint32_t _buf_size)
{
  (void) _buf_size;
@[if len(spec.fields) > 0]@
  const __ros_msg_type * _s = &ros_message;
@[else]@
  (void) ros_message;
@[end if]@
  uint8_t * _p = _buf;

  if ((uintptr_t)_p & 3) {
    _p += 4 - ((uintptr_t)_p & 3);
  }

@{
align = 4
for field in spec.fields:
    align, substring = serialize_field(field, align)
    print(substring)
}@

  return static_cast<uint32_t>(_p - _buf);
}

// TODO: Partial specialization functions

ROSIDL_TYPESUPPORT_FREERTPS_CPP_EXPORT_@(spec.base_type.pkg_name)
bool deserialize_ros_msg(
  uint8_t ** _p,
  @(spec.base_type.pkg_name)::@(subfolder)::@(spec.base_type.type) & ros_message,
  uint32_t * _len)
{
  @[if len(spec.fields) > 0]@
  __ros_msg_type * _s = &ros_message;
  @[else]@
  (void) ros_message;
  @[end if]@
  if ((uintptr_t)*_p & 3)
  {
    _len -= 4 - ((uintptr_t)*_p & 3);
    *_p += 4 - ((uintptr_t)*_p & 3);
  }

  @{
align = 4
for field in spec.fields:
    align, substring = deserialize_field(field, align)
    print(substring)
  }@
  return true;
}


ROSIDL_TYPESUPPORT_FREERTPS_CPP_EXPORT_@(spec.base_type.pkg_name)
const char *
publish__@(spec.base_type.type)(
  void *untyped_pub,
  const void *untyped_ros_message)
{
  (void)untyped_pub;
  const __ros_msg_type & ros_message = *(const __ros_msg_type *)untyped_ros_message;
  // TODO memory allocation! does the buffer get passed to this function?
  // TODO freertps currently only supports fixed-size arrays so sizeof is OK (we think?)
  uint32_t _len = sizeof(__ros_msg_type);
  uint8_t * buf = static_cast<uint8_t *>(calloc(_len, sizeof(uint8_t)));
  serialize_ros_msg(ros_message, buf, _len);

  frudp_pub_t *pub = (frudp_pub_t *)untyped_pub;
  freertps_publish(pub, (uint8_t *)buf, _len);
  return nullptr;
}


ROSIDL_TYPESUPPORT_FREERTPS_CPP_EXPORT_@(spec.base_type.pkg_name)
const char *
take__@(spec.base_type.type)(
  void * untyped_topic_reader,
  bool ignore_local_publications,
  void * untyped_ros_message,
  bool * taken)
{
  if (untyped_ros_message == 0) {
    return "invalid ros message pointer";
  };

  (void)untyped_topic_reader;
  (void)ignore_local_publications;
  (void)taken;

  return "not yet implemented";
}

static message_type_support_callbacks_t message_type_support_callbacks = {
  "@(spec.base_type.pkg_name)",
  "@(spec.base_type.type)",
  &publish__@(spec.base_type.type),
};

static rosidl_message_type_support_t handle = {
  rosidl_typesupport_freertps_cpp::typesupport_freertps_identifier,
  &message_type_support_callbacks
};


}  // namespace typesupport_freertps_cpp

}  // namespace @(subfolder)

}  // namespace @(spec.base_type.pkg_name)

namespace rosidl_typesupport_freertps_cpp
{

template<>
ROSIDL_TYPESUPPORT_FREERTPS_CPP_EXPORT
const rosidl_message_type_support_t *
get_message_type_support_handle_freertps<
  @(spec.base_type.pkg_name)::@(subfolder)::@(spec.base_type.type)
>()
{
  return &@(spec.base_type.pkg_name)::@(subfolder)::typesupport_freertps_cpp::handle;
}

}  // namespace rosidl_typesupport_freertps_cpp
