// generated from rosidl_typesupport_freertps_cpp/resource/msg__type_support.cpp.template

@#######################################################################
@# EmPy template for generating <msg>__type_support.cpp files
@#
@# Context:
@#  - spec (rosidl_parser.MessageSpecification)
@#    Parsed specification of the .msg file
@#  - subfolder (string)
@#    The subfolder / subnamespace of the message
@#    Either 'msg' or 'srv'
@#  - get_header_filename_from_msg_name (function)
@#######################################################################
@
#include <limits>
#include <stdexcept>
#include <cstring>

extern "C"
{
#include "freertps/pub.h"
#include "freertps/freertps.h"
}

#include <rosidl_generator_c/message_type_support.h>
// this is defined in the rosidl_typesupport_freertps_cpp package and
// is in the include/rosidl_typesupport_freertps_cpp/impl folder
#include <rosidl_generator_cpp/message_type_support.hpp>
#include <rosidl_typesupport_freertps_cpp/visibility_control.h>

@{header_file_name = get_header_filename_from_msg_name(spec.base_type.type)}@
#include "@(spec.base_type.pkg_name)/@(subfolder)/@(header_file_name)__struct.hpp"
#include "@(spec.base_type.pkg_name)/@(subfolder)/dds_freertps/@(header_file_name)__type_support.hpp"
//#include "@(spec.base_type.pkg_name)/@(subfolder)/dds_freertps/ccpp_@(spec.base_type.type)_.h"
#include "rosidl_typesupport_freertps_cpp/identifier.hpp"
#include <rosidl_typesupport_freertps_cpp/message_type_support.h>

// forward declaration of message dependencies and their conversion functions
@[for field in spec.fields]@
@[if not field.type.is_primitive_type()]@
@[if field.type.pkg_name == 'builtin_interfaces']@
#include "rosidl_typesupport_freertps_cpp/duration__type_support.hpp"
#include "rosidl_typesupport_freertps_cpp/time__type_support.hpp"
@[else]@
namespace @(field.type.pkg_name)
{
namespace msg
{
namespace dds_
{
struct @(field.type.type)_;
}  // namespace dds_
namespace typesupport_freertps_cpp
{
void convert_ros_message_to_dds(
  const @(field.type.pkg_name)::msg::@(field.type.type) &,
  @(field.type.pkg_name)::msg::dds_::@(field.type.type)_ &);
void convert_dds_message_to_ros(
  const @(field.type.pkg_name)::msg::dds_::@(field.type.type)_ &,
  @(field.type.pkg_name)::msg::@(field.type.type) &);
}  // namespace typesupport_freertps_cpp
}  // namespace msg
}  // namespace @(field.type.pkg_name)
@[end if]@

@[end if]@
@[end for]@

namespace @(spec.base_type.pkg_name)
{

namespace @(subfolder)
{

namespace typesupport_freertps_cpp
{

@{
__dds_msg_type_prefix = "{}::{}::dds_::{}_".format(
  spec.base_type.pkg_name, subfolder, spec.base_type.type)
}@

#if 0
typedef @(__dds_msg_type_prefix) __dds_msg_type;
#endif
typedef @(spec.base_type.pkg_name)::@(subfolder)::@(spec.base_type.type) __ros_msg_type;

ROSIDL_TYPESUPPORT_FREERTPS_CPP_EXPORT_@(spec.base_type.pkg_name)
const char *
register_type__@(spec.base_type.type)(
  void * untyped_participant,
  const char * type_name)
{
  if (!untyped_participant) {
    return "untyped participant handle is null";
  }
  if (!type_name) {
    return "type name handle is null";
  }
  return "not yet implemented";
}


ROSIDL_TYPESUPPORT_FREERTPS_CPP_EXPORT_@(spec.base_type.pkg_name)
const char *
publish__@(spec.base_type.type)(
  void *untyped_pub,
  const void *untyped_ros_message)
{
  //(void)untyped_topic_writer;
  (void)untyped_pub;
  const __ros_msg_type & ros_message = *(const __ros_msg_type *)untyped_ros_message;

@[if __dds_msg_type_prefix == "std_msgs::msg::dds_::String_"]@
  //printf(" ok to publish\n");
  static char ser_buf[256];
  int s_len = (int)ros_message.data.length();
  //printf("  len = %d\n", s_len);
  //snprintf(&ser_buf[4], sizeof(msg) - 4, "Hello World: %d", pub_count++);
  if (s_len + 4 + 1 > (int)sizeof(ser_buf) - 5)
    s_len = (int)sizeof(ser_buf) - 5;
  memcpy(&ser_buf[4], &ros_message.data[0], s_len);
  ser_buf[s_len + 5] = 0; // add a null char plz
  //uint32_t rtps_string_len = strlen(&msg[4]) + 1;
  *((uint32_t *)ser_buf) = s_len + 1; // add 1 for the null char at the end
  frudp_pub_t *pub = (frudp_pub_t *)untyped_pub;
  freertps_publish(pub, (uint8_t *)ser_buf, s_len + 5);
  return nullptr;
@[else]@
  (void)ros_message;
  return "serialization of [@(__dds_msg_type_prefix)] not yet implemented\n";
@[end if]@
}


ROSIDL_TYPESUPPORT_FREERTPS_CPP_EXPORT_@(spec.base_type.pkg_name)
const char *
take__@(spec.base_type.type)(
  void * untyped_topic_reader,
  bool ignore_local_publications,
  void * untyped_ros_message,
  bool * taken)
{
  if (untyped_ros_message == 0) {
    return "invalid ros message pointer";
  };
  (void)untyped_topic_reader;
  (void)ignore_local_publications;
  (void)taken;

  return "not yet implemented";
}

static message_type_support_callbacks_t message_type_support_callbacks = {
  "@(spec.base_type.pkg_name)",
  "@(spec.base_type.type)",
  &publish__@(spec.base_type.type),
};
/*
  &register_type__@(spec.base_type.type),
  &take__@(spec.base_type.type)
};
*/

static rosidl_message_type_support_t handle = {
  rosidl_typesupport_freertps_cpp::typesupport_freertps_identifier,
  &message_type_support_callbacks
};


}  // namespace typesupport_freertps_cpp

}  // namespace @(subfolder)

}  // namespace @(spec.base_type.pkg_name)

namespace rosidl_typesupport_freertps_cpp
{

template<>
ROSIDL_TYPESUPPORT_FREERTPS_CPP_EXPORT
const rosidl_message_type_support_t *
get_message_type_support_handle_freertps<
  @(spec.base_type.pkg_name)::@(subfolder)::@(spec.base_type.type)
>()
{
  return &@(spec.base_type.pkg_name)::@(subfolder)::typesupport_freertps_cpp::handle;
}

}  // namespace rosidl_typesupport_freertps_cpp
