// generated from rosidl_typesupport_opensplice_cpp/resource/msg__type_support.hpp.template

@#######################################################################
@# EmPy template for generating <msg>__type_support.hpp files
@#
@# Context:
@#  - spec (rosidl_parser.MessageSpecifiwcation)
@#    Parsed specification of the .msg file
@#  - subfolder (string)
@#    The subfolder / subnamespace of the message
@#    Either 'msg' or 'srv'
@#  - get_header_filename_from_msg_name (function)
@#######################################################################
@
#ifndef __@(spec.base_type.pkg_name)__@(subfolder)__dds_freertps__@(get_header_filename_from_msg_name(spec.base_type.type))__type_support__hpp__
#define __@(spec.base_type.pkg_name)__@(subfolder)__dds_freertps__@(get_header_filename_from_msg_name(spec.base_type.type))__type_support__hpp__

@{header_file_name = get_header_filename_from_msg_name(spec.base_type.type)}@
#include "@(spec.base_type.pkg_name)/@(subfolder)/@(header_file_name)__struct.hpp"
#include "@(spec.base_type.pkg_name)/msg/dds_freertps/visibility_control.h"

// Include serialization/deserialization for all first-order subfields of this message
@[for field in spec.fields]@
@[if not field.type.is_primitive_type()]@
@{
dependency_subfolder = "msg"
if field.type.type.endswith("Request") or field.type.type.endswith("Response"):
    dependency_subfolder = "srv"
}@
#include "@(field.type.pkg_name)/@(dependency_subfolder)/dds_freertps/@(get_header_filename_from_msg_name(field.type.type))__type_support.hpp"
@[end if]@
@[end for]@

namespace @(spec.base_type.pkg_name)
{

namespace @(subfolder)
{

namespace typesupport_opensplice_cpp
{

/// Serialize the ROS message to CDR format.
/**
 * \param[in] ros_message The ROS message struct to convert.
 * \param[in] buf Pointer to memory area where the serialized message will be stored.
 * \param[in] size Size of the message
 */
ROSIDL_TYPESUPPORT_FREERTPS_CPP_PUBLIC_@(spec.base_type.pkg_name)
extern uint32_t serialize_ros_msg(
  const @(spec.base_type.pkg_name)::@(subfolder)::@(spec.base_type.type) & ros_message,
  uint8_t * buf,
  uint32_t size);

/// Deserialize the serialized pointer to ROS message format.
/**
 * \param[in] message_pointer The serialized message to convert.
 * \param[out] ros_msg The deserialized ROS message
 * \param[in] length How many bytes are represented by message_pointer.
 */
ROSIDL_TYPESUPPORT_FREERTPS_CPP_PUBLIC_@(spec.base_type.pkg_name)
extern bool deserialize_ros_msg(
  uint8_t ** message_pointer,
  @(spec.base_type.pkg_name)::@(subfolder)::@(spec.base_type.type) & ros_message,
  uint32_t * length);


ROSIDL_TYPESUPPORT_FREERTPS_CPP_PUBLIC_@(spec.base_type.pkg_name)
extern const char * publish__@(spec.base_type.type)(
  void * untyped_topic_writer,
  const void * untyped_ros_message);

ROSIDL_TYPESUPPORT_FREERTPS_CPP_PUBLIC_@(spec.base_type.pkg_name)
extern const char * take__@(spec.base_type.type)(
  void * untyped_topic_reader,
  bool ignore_local_publications,
  void * untyped_ros_message,
  bool * taken);

}  // namespace typesupport_opensplice_cpp

}  // namespace @(subfolder)

}  // namespace @(spec.base_type.pkg_name)

#endif  // __@(spec.base_type.pkg_name)__@(subfolder)__dds_freertps__@(get_header_filename_from_msg_name(spec.base_type.type))__type_support__hpp__
